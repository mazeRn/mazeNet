// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "mazeCom.hxx"

#include <xsd/cxx/xml/dom/parsing-source.hxx>

// MazeComType
//

MazeComType::
MazeComType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_MazeComType_convert ();
}

MazeComType::
MazeComType (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_MazeComType_convert ();
}

MazeComType::
MazeComType (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_MazeComType_convert ();
}

MazeComType* MazeComType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MazeComType (*this, f, c);
}

MazeComType::value MazeComType::
_xsd_MazeComType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_MazeComType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_MazeComType_indexes_,
                    _xsd_MazeComType_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_MazeComType_indexes_ + 7 || _xsd_MazeComType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const MazeComType::
_xsd_MazeComType_literals_[7] =
{
  "LOGIN",
  "LOGINREPLY",
  "AWAITMOVE",
  "MOVE",
  "ACCEPT",
  "WIN",
  "DISCONNECT"
};

const MazeComType::value MazeComType::
_xsd_MazeComType_indexes_[7] =
{
  ::MazeComType::ACCEPT,
  ::MazeComType::AWAITMOVE,
  ::MazeComType::DISCONNECT,
  ::MazeComType::LOGIN,
  ::MazeComType::LOGINREPLY,
  ::MazeComType::MOVE,
  ::MazeComType::WIN
};

// treasureType
//

treasureType::
treasureType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_treasureType_convert ();
}

treasureType::
treasureType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_treasureType_convert ();
}

treasureType::
treasureType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_treasureType_convert ();
}

treasureType* treasureType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class treasureType (*this, f, c);
}

treasureType::value treasureType::
_xsd_treasureType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_treasureType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_treasureType_indexes_,
                    _xsd_treasureType_indexes_ + 28,
                    *this,
                    c));

  if (i == _xsd_treasureType_indexes_ + 28 || _xsd_treasureType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const treasureType::
_xsd_treasureType_literals_[28] =
{
  "Start01",
  "Start02",
  "Start03",
  "Start04",
  "sym01",
  "sym02",
  "sym03",
  "sym04",
  "sym05",
  "sym06",
  "sym07",
  "sym08",
  "sym09",
  "sym10",
  "sym11",
  "sym12",
  "sym13",
  "sym14",
  "sym15",
  "sym16",
  "sym17",
  "sym18",
  "sym19",
  "sym20",
  "sym21",
  "sym22",
  "sym23",
  "sym24"
};

const treasureType::value treasureType::
_xsd_treasureType_indexes_[28] =
{
  ::treasureType::Start01,
  ::treasureType::Start02,
  ::treasureType::Start03,
  ::treasureType::Start04,
  ::treasureType::sym01,
  ::treasureType::sym02,
  ::treasureType::sym03,
  ::treasureType::sym04,
  ::treasureType::sym05,
  ::treasureType::sym06,
  ::treasureType::sym07,
  ::treasureType::sym08,
  ::treasureType::sym09,
  ::treasureType::sym10,
  ::treasureType::sym11,
  ::treasureType::sym12,
  ::treasureType::sym13,
  ::treasureType::sym14,
  ::treasureType::sym15,
  ::treasureType::sym16,
  ::treasureType::sym17,
  ::treasureType::sym18,
  ::treasureType::sym19,
  ::treasureType::sym20,
  ::treasureType::sym21,
  ::treasureType::sym22,
  ::treasureType::sym23,
  ::treasureType::sym24
};

// ErrorType
//

ErrorType::
ErrorType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ErrorType_convert ();
}

ErrorType::
ErrorType (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ErrorType_convert ();
}

ErrorType::
ErrorType (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ErrorType_convert ();
}

ErrorType* ErrorType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ErrorType (*this, f, c);
}

ErrorType::value ErrorType::
_xsd_ErrorType_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ErrorType_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ErrorType_indexes_,
                    _xsd_ErrorType_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_ErrorType_indexes_ + 7 || _xsd_ErrorType_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ErrorType::
_xsd_ErrorType_literals_[7] =
{
  "NOERROR",
  "ERROR",
  "AWAIT_LOGIN",
  "AWAIT_MOVE",
  "ILLEGAL_MOVE",
  "TIMEOUT",
  "TOO_MANY_TRIES"
};

const ErrorType::value ErrorType::
_xsd_ErrorType_indexes_[7] =
{
  ::ErrorType::AWAIT_LOGIN,
  ::ErrorType::AWAIT_MOVE,
  ::ErrorType::ERROR,
  ::ErrorType::ILLEGAL_MOVE,
  ::ErrorType::NOERROR,
  ::ErrorType::TIMEOUT,
  ::ErrorType::TOO_MANY_TRIES
};

// cardType
//

cardType::
cardType (const openings_type& openings,
          const pin_type& pin)
: ::xml_schema::type (),
  openings_ (openings, this),
  pin_ (pin, this),
  treasure_ (this)
{
}

cardType::
cardType (::std::unique_ptr< openings_type > openings,
          ::std::unique_ptr< pin_type > pin)
: ::xml_schema::type (),
  openings_ (std::move (openings), this),
  pin_ (std::move (pin), this),
  treasure_ (this)
{
}

cardType::
cardType (const cardType& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  openings_ (x.openings_, f, this),
  pin_ (x.pin_, f, this),
  treasure_ (x.treasure_, f, this)
{
}

cardType::
cardType (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  openings_ (this),
  pin_ (this),
  treasure_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cardType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // openings
    //
    if (n.name () == "openings" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< openings_type > r (
        openings_traits::create (i, f, this));

      if (!openings_.present ())
      {
        this->openings_.set (::std::move (r));
        continue;
      }
    }

    // pin
    //
    if (n.name () == "pin" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< pin_type > r (
        pin_traits::create (i, f, this));

      if (!pin_.present ())
      {
        this->pin_.set (::std::move (r));
        continue;
      }
    }

    // treasure
    //
    if (n.name () == "treasure" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< treasure_type > r (
        treasure_traits::create (i, f, this));

      if (!this->treasure_)
      {
        this->treasure_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!openings_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "openings",
      "");
  }

  if (!pin_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "pin",
      "");
  }
}

cardType* cardType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cardType (*this, f, c);
}

cardType& cardType::
operator= (const cardType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->openings_ = x.openings_;
    this->pin_ = x.pin_;
    this->treasure_ = x.treasure_;
  }

  return *this;
}

cardType::
~cardType ()
{
}

// boardType
//

boardType::
boardType (const shiftCard_type& shiftCard)
: ::xml_schema::type (),
  row_ (this),
  shiftCard_ (shiftCard, this),
  forbidden_ (this)
{
}

boardType::
boardType (::std::unique_ptr< shiftCard_type > shiftCard)
: ::xml_schema::type (),
  row_ (this),
  shiftCard_ (std::move (shiftCard), this),
  forbidden_ (this)
{
}

boardType::
boardType (const boardType& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  row_ (x.row_, f, this),
  shiftCard_ (x.shiftCard_, f, this),
  forbidden_ (x.forbidden_, f, this)
{
}

boardType::
boardType (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  row_ (this),
  shiftCard_ (this),
  forbidden_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void boardType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // row
    //
    if (n.name () == "row" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< row_type > r (
        row_traits::create (i, f, this));

      this->row_.push_back (::std::move (r));
      continue;
    }

    // shiftCard
    //
    if (n.name () == "shiftCard" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< shiftCard_type > r (
        shiftCard_traits::create (i, f, this));

      if (!shiftCard_.present ())
      {
        this->shiftCard_.set (::std::move (r));
        continue;
      }
    }

    // forbidden
    //
    if (n.name () == "forbidden" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< forbidden_type > r (
        forbidden_traits::create (i, f, this));

      if (!this->forbidden_)
      {
        this->forbidden_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!shiftCard_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "shiftCard",
      "");
  }
}

boardType* boardType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boardType (*this, f, c);
}

boardType& boardType::
operator= (const boardType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->row_ = x.row_;
    this->shiftCard_ = x.shiftCard_;
    this->forbidden_ = x.forbidden_;
  }

  return *this;
}

boardType::
~boardType ()
{
}

// positionType
//

positionType::
positionType (const row_type& row,
              const col_type& col)
: ::xml_schema::type (),
  row_ (row, this),
  col_ (col, this)
{
}

positionType::
positionType (const positionType& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  row_ (x.row_, f, this),
  col_ (x.col_, f, this)
{
}

positionType::
positionType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  row_ (this),
  col_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void positionType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // row
    //
    if (n.name () == "row" && n.namespace_ ().empty ())
    {
      if (!row_.present ())
      {
        this->row_.set (row_traits::create (i, f, this));
        continue;
      }
    }

    // col
    //
    if (n.name () == "col" && n.namespace_ ().empty ())
    {
      if (!col_.present ())
      {
        this->col_.set (col_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!row_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "row",
      "");
  }

  if (!col_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "col",
      "");
  }
}

positionType* positionType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class positionType (*this, f, c);
}

positionType& positionType::
operator= (const positionType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->row_ = x.row_;
    this->col_ = x.col_;
  }

  return *this;
}

positionType::
~positionType ()
{
}

// LoginMessageType
//

LoginMessageType::
LoginMessageType (const name_type& name)
: ::xml_schema::type (),
  name_ (name, this)
{
}

LoginMessageType::
LoginMessageType (const LoginMessageType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this)
{
}

LoginMessageType::
LoginMessageType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void LoginMessageType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }
}

LoginMessageType* LoginMessageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LoginMessageType (*this, f, c);
}

LoginMessageType& LoginMessageType::
operator= (const LoginMessageType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
  }

  return *this;
}

LoginMessageType::
~LoginMessageType ()
{
}

// LoginReplyMessageType
//

LoginReplyMessageType::
LoginReplyMessageType (const newID_type& newID)
: ::xml_schema::type (),
  newID_ (newID, this)
{
}

LoginReplyMessageType::
LoginReplyMessageType (const LoginReplyMessageType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  newID_ (x.newID_, f, this)
{
}

LoginReplyMessageType::
LoginReplyMessageType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  newID_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void LoginReplyMessageType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // newID
    //
    if (n.name () == "newID" && n.namespace_ ().empty ())
    {
      if (!newID_.present ())
      {
        this->newID_.set (newID_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!newID_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "newID",
      "");
  }
}

LoginReplyMessageType* LoginReplyMessageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class LoginReplyMessageType (*this, f, c);
}

LoginReplyMessageType& LoginReplyMessageType::
operator= (const LoginReplyMessageType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->newID_ = x.newID_;
  }

  return *this;
}

LoginReplyMessageType::
~LoginReplyMessageType ()
{
}

// AwaitMoveMessageType
//

AwaitMoveMessageType::
AwaitMoveMessageType (const board_type& board,
                      const treasure_type& treasure)
: ::xml_schema::type (),
  board_ (board, this),
  treasuresToGo_ (this),
  foundTreasures_ (this),
  treasure_ (treasure, this)
{
}

AwaitMoveMessageType::
AwaitMoveMessageType (::std::unique_ptr< board_type > board,
                      const treasure_type& treasure)
: ::xml_schema::type (),
  board_ (std::move (board), this),
  treasuresToGo_ (this),
  foundTreasures_ (this),
  treasure_ (treasure, this)
{
}

AwaitMoveMessageType::
AwaitMoveMessageType (const AwaitMoveMessageType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  board_ (x.board_, f, this),
  treasuresToGo_ (x.treasuresToGo_, f, this),
  foundTreasures_ (x.foundTreasures_, f, this),
  treasure_ (x.treasure_, f, this)
{
}

AwaitMoveMessageType::
AwaitMoveMessageType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  board_ (this),
  treasuresToGo_ (this),
  foundTreasures_ (this),
  treasure_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void AwaitMoveMessageType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // board
    //
    if (n.name () == "board" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< board_type > r (
        board_traits::create (i, f, this));

      if (!board_.present ())
      {
        this->board_.set (::std::move (r));
        continue;
      }
    }

    // treasuresToGo
    //
    if (n.name () == "treasuresToGo" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< treasuresToGo_type > r (
        treasuresToGo_traits::create (i, f, this));

      this->treasuresToGo_.push_back (::std::move (r));
      continue;
    }

    // foundTreasures
    //
    if (n.name () == "foundTreasures" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< foundTreasures_type > r (
        foundTreasures_traits::create (i, f, this));

      this->foundTreasures_.push_back (::std::move (r));
      continue;
    }

    // treasure
    //
    if (n.name () == "treasure" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< treasure_type > r (
        treasure_traits::create (i, f, this));

      if (!treasure_.present ())
      {
        this->treasure_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!board_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "board",
      "");
  }

  if (!treasure_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "treasure",
      "");
  }
}

AwaitMoveMessageType* AwaitMoveMessageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AwaitMoveMessageType (*this, f, c);
}

AwaitMoveMessageType& AwaitMoveMessageType::
operator= (const AwaitMoveMessageType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->board_ = x.board_;
    this->treasuresToGo_ = x.treasuresToGo_;
    this->foundTreasures_ = x.foundTreasures_;
    this->treasure_ = x.treasure_;
  }

  return *this;
}

AwaitMoveMessageType::
~AwaitMoveMessageType ()
{
}

// TreasuresToGoType
//

TreasuresToGoType::
TreasuresToGoType (const player_type& player,
                   const treasures_type& treasures)
: ::xml_schema::type (),
  player_ (player, this),
  treasures_ (treasures, this)
{
}

TreasuresToGoType::
TreasuresToGoType (const TreasuresToGoType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  player_ (x.player_, f, this),
  treasures_ (x.treasures_, f, this)
{
}

TreasuresToGoType::
TreasuresToGoType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  player_ (this),
  treasures_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void TreasuresToGoType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // player
    //
    if (n.name () == "player" && n.namespace_ ().empty ())
    {
      if (!player_.present ())
      {
        this->player_.set (player_traits::create (i, f, this));
        continue;
      }
    }

    // treasures
    //
    if (n.name () == "treasures" && n.namespace_ ().empty ())
    {
      if (!treasures_.present ())
      {
        this->treasures_.set (treasures_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!player_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "player",
      "");
  }

  if (!treasures_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "treasures",
      "");
  }
}

TreasuresToGoType* TreasuresToGoType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class TreasuresToGoType (*this, f, c);
}

TreasuresToGoType& TreasuresToGoType::
operator= (const TreasuresToGoType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->player_ = x.player_;
    this->treasures_ = x.treasures_;
  }

  return *this;
}

TreasuresToGoType::
~TreasuresToGoType ()
{
}

// MoveMessageType
//

MoveMessageType::
MoveMessageType (const shiftPosition_type& shiftPosition,
                 const newPinPos_type& newPinPos,
                 const shiftCard_type& shiftCard)
: ::xml_schema::type (),
  shiftPosition_ (shiftPosition, this),
  newPinPos_ (newPinPos, this),
  shiftCard_ (shiftCard, this)
{
}

MoveMessageType::
MoveMessageType (::std::unique_ptr< shiftPosition_type > shiftPosition,
                 ::std::unique_ptr< newPinPos_type > newPinPos,
                 ::std::unique_ptr< shiftCard_type > shiftCard)
: ::xml_schema::type (),
  shiftPosition_ (std::move (shiftPosition), this),
  newPinPos_ (std::move (newPinPos), this),
  shiftCard_ (std::move (shiftCard), this)
{
}

MoveMessageType::
MoveMessageType (const MoveMessageType& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  shiftPosition_ (x.shiftPosition_, f, this),
  newPinPos_ (x.newPinPos_, f, this),
  shiftCard_ (x.shiftCard_, f, this)
{
}

MoveMessageType::
MoveMessageType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  shiftPosition_ (this),
  newPinPos_ (this),
  shiftCard_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void MoveMessageType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // shiftPosition
    //
    if (n.name () == "shiftPosition" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< shiftPosition_type > r (
        shiftPosition_traits::create (i, f, this));

      if (!shiftPosition_.present ())
      {
        this->shiftPosition_.set (::std::move (r));
        continue;
      }
    }

    // newPinPos
    //
    if (n.name () == "newPinPos" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< newPinPos_type > r (
        newPinPos_traits::create (i, f, this));

      if (!newPinPos_.present ())
      {
        this->newPinPos_.set (::std::move (r));
        continue;
      }
    }

    // shiftCard
    //
    if (n.name () == "shiftCard" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< shiftCard_type > r (
        shiftCard_traits::create (i, f, this));

      if (!shiftCard_.present ())
      {
        this->shiftCard_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!shiftPosition_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "shiftPosition",
      "");
  }

  if (!newPinPos_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "newPinPos",
      "");
  }

  if (!shiftCard_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "shiftCard",
      "");
  }
}

MoveMessageType* MoveMessageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MoveMessageType (*this, f, c);
}

MoveMessageType& MoveMessageType::
operator= (const MoveMessageType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->shiftPosition_ = x.shiftPosition_;
    this->newPinPos_ = x.newPinPos_;
    this->shiftCard_ = x.shiftCard_;
  }

  return *this;
}

MoveMessageType::
~MoveMessageType ()
{
}

// AcceptMessageType
//

AcceptMessageType::
AcceptMessageType (const accept_type& accept,
                   const errorCode_type& errorCode)
: ::xml_schema::type (),
  accept_ (accept, this),
  errorCode_ (errorCode, this)
{
}

AcceptMessageType::
AcceptMessageType (const AcceptMessageType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  accept_ (x.accept_, f, this),
  errorCode_ (x.errorCode_, f, this)
{
}

AcceptMessageType::
AcceptMessageType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  accept_ (this),
  errorCode_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void AcceptMessageType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // accept
    //
    if (n.name () == "accept" && n.namespace_ ().empty ())
    {
      if (!accept_.present ())
      {
        this->accept_.set (accept_traits::create (i, f, this));
        continue;
      }
    }

    // errorCode
    //
    if (n.name () == "errorCode" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< errorCode_type > r (
        errorCode_traits::create (i, f, this));

      if (!errorCode_.present ())
      {
        this->errorCode_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!accept_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "accept",
      "");
  }

  if (!errorCode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "errorCode",
      "");
  }
}

AcceptMessageType* AcceptMessageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AcceptMessageType (*this, f, c);
}

AcceptMessageType& AcceptMessageType::
operator= (const AcceptMessageType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->accept_ = x.accept_;
    this->errorCode_ = x.errorCode_;
  }

  return *this;
}

AcceptMessageType::
~AcceptMessageType ()
{
}

// WinMessageType
//

WinMessageType::
WinMessageType (const board_type& board,
                const winner_type& winner)
: ::xml_schema::type (),
  board_ (board, this),
  winner_ (winner, this)
{
}

WinMessageType::
WinMessageType (::std::unique_ptr< board_type > board,
                ::std::unique_ptr< winner_type > winner)
: ::xml_schema::type (),
  board_ (std::move (board), this),
  winner_ (std::move (winner), this)
{
}

WinMessageType::
WinMessageType (const WinMessageType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  board_ (x.board_, f, this),
  winner_ (x.winner_, f, this)
{
}

WinMessageType::
WinMessageType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  board_ (this),
  winner_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void WinMessageType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // board
    //
    if (n.name () == "board" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< board_type > r (
        board_traits::create (i, f, this));

      if (!board_.present ())
      {
        this->board_.set (::std::move (r));
        continue;
      }
    }

    // winner
    //
    if (n.name () == "winner" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< winner_type > r (
        winner_traits::create (i, f, this));

      if (!winner_.present ())
      {
        this->winner_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!board_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "board",
      "");
  }

  if (!winner_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "winner",
      "");
  }
}

WinMessageType* WinMessageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class WinMessageType (*this, f, c);
}

WinMessageType& WinMessageType::
operator= (const WinMessageType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->board_ = x.board_;
    this->winner_ = x.winner_;
  }

  return *this;
}

WinMessageType::
~WinMessageType ()
{
}

// DisconnectMessageType
//

DisconnectMessageType::
DisconnectMessageType (const name_type& name,
                       const errorCode_type& errorCode)
: ::xml_schema::type (),
  name_ (name, this),
  errorCode_ (errorCode, this)
{
}

DisconnectMessageType::
DisconnectMessageType (const DisconnectMessageType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_ (x.name_, f, this),
  errorCode_ (x.errorCode_, f, this)
{
}

DisconnectMessageType::
DisconnectMessageType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_ (this),
  errorCode_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void DisconnectMessageType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name_.set (::std::move (r));
        continue;
      }
    }

    // errorCode
    //
    if (n.name () == "errorCode" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< errorCode_type > r (
        errorCode_traits::create (i, f, this));

      if (!errorCode_.present ())
      {
        this->errorCode_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!errorCode_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "errorCode",
      "");
  }
}

DisconnectMessageType* DisconnectMessageType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class DisconnectMessageType (*this, f, c);
}

DisconnectMessageType& DisconnectMessageType::
operator= (const DisconnectMessageType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_ = x.name_;
    this->errorCode_ = x.errorCode_;
  }

  return *this;
}

DisconnectMessageType::
~DisconnectMessageType ()
{
}

// openings
//

openings::
openings (const top_type& top,
          const bottom_type& bottom,
          const left_type& left,
          const right_type& right)
: ::xml_schema::type (),
  top_ (top, this),
  bottom_ (bottom, this),
  left_ (left, this),
  right_ (right, this)
{
}

openings::
openings (const openings& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  top_ (x.top_, f, this),
  bottom_ (x.bottom_, f, this),
  left_ (x.left_, f, this),
  right_ (x.right_, f, this)
{
}

openings::
openings (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  top_ (this),
  bottom_ (this),
  left_ (this),
  right_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void openings::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // top
    //
    if (n.name () == "top" && n.namespace_ ().empty ())
    {
      if (!top_.present ())
      {
        this->top_.set (top_traits::create (i, f, this));
        continue;
      }
    }

    // bottom
    //
    if (n.name () == "bottom" && n.namespace_ ().empty ())
    {
      if (!bottom_.present ())
      {
        this->bottom_.set (bottom_traits::create (i, f, this));
        continue;
      }
    }

    // left
    //
    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      if (!left_.present ())
      {
        this->left_.set (left_traits::create (i, f, this));
        continue;
      }
    }

    // right
    //
    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      if (!right_.present ())
      {
        this->right_.set (right_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!top_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "top",
      "");
  }

  if (!bottom_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "bottom",
      "");
  }

  if (!left_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "left",
      "");
  }

  if (!right_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "right",
      "");
  }
}

openings* openings::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class openings (*this, f, c);
}

openings& openings::
operator= (const openings& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->top_ = x.top_;
    this->bottom_ = x.bottom_;
    this->left_ = x.left_;
    this->right_ = x.right_;
  }

  return *this;
}

openings::
~openings ()
{
}

// pin
//

pin::
pin ()
: ::xml_schema::type (),
  playerID_ (this)
{
}

pin::
pin (const pin& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  playerID_ (x.playerID_, f, this)
{
}

pin::
pin (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  playerID_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void pin::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // playerID
    //
    if (n.name () == "playerID" && n.namespace_ ().empty ())
    {
      this->playerID_.push_back (playerID_traits::create (i, f, this));
      continue;
    }

    break;
  }
}

pin* pin::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class pin (*this, f, c);
}

pin& pin::
operator= (const pin& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->playerID_ = x.playerID_;
  }

  return *this;
}

pin::
~pin ()
{
}

// row
//

row::
row ()
: ::xml_schema::type (),
  col_ (this),
  OptionalAttirbute_ (this)
{
}

row::
row (const row& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  col_ (x.col_, f, this),
  OptionalAttirbute_ (x.OptionalAttirbute_, f, this)
{
}

row::
row (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  col_ (this),
  OptionalAttirbute_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void row::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // col
    //
    if (n.name () == "col" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< col_type > r (
        col_traits::create (i, f, this));

      this->col_.push_back (::std::move (r));
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "OptionalAttirbute" && n.namespace_ ().empty ())
    {
      this->OptionalAttirbute_.set (OptionalAttirbute_traits::create (i, f, this));
      continue;
    }
  }
}

row* row::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class row (*this, f, c);
}

row& row::
operator= (const row& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->col_ = x.col_;
    this->OptionalAttirbute_ = x.OptionalAttirbute_;
  }

  return *this;
}

row::
~row ()
{
}

// MazeCom
//

MazeCom::
MazeCom (const mcType_type& mcType,
         const id_type& id)
: ::xml_schema::type (),
  LoginMessage_ (this),
  LoginReplyMessage_ (this),
  AwaitMoveMessage_ (this),
  MoveMessage_ (this),
  AcceptMessage_ (this),
  WinMessage_ (this),
  DisconnectMessage_ (this),
  mcType_ (mcType, this),
  id_ (id, this)
{
}

MazeCom::
MazeCom (const MazeCom& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  LoginMessage_ (x.LoginMessage_, f, this),
  LoginReplyMessage_ (x.LoginReplyMessage_, f, this),
  AwaitMoveMessage_ (x.AwaitMoveMessage_, f, this),
  MoveMessage_ (x.MoveMessage_, f, this),
  AcceptMessage_ (x.AcceptMessage_, f, this),
  WinMessage_ (x.WinMessage_, f, this),
  DisconnectMessage_ (x.DisconnectMessage_, f, this),
  mcType_ (x.mcType_, f, this),
  id_ (x.id_, f, this)
{
}

MazeCom::
MazeCom (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  LoginMessage_ (this),
  LoginReplyMessage_ (this),
  AwaitMoveMessage_ (this),
  MoveMessage_ (this),
  AcceptMessage_ (this),
  WinMessage_ (this),
  DisconnectMessage_ (this),
  mcType_ (this),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void MazeCom::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LoginMessage
    //
    if (n.name () == "LoginMessage" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< LoginMessage_type > r (
        LoginMessage_traits::create (i, f, this));

      if (!this->LoginMessage_)
      {
        this->LoginMessage_.set (::std::move (r));
        continue;
      }
    }

    // LoginReplyMessage
    //
    if (n.name () == "LoginReplyMessage" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< LoginReplyMessage_type > r (
        LoginReplyMessage_traits::create (i, f, this));

      if (!this->LoginReplyMessage_)
      {
        this->LoginReplyMessage_.set (::std::move (r));
        continue;
      }
    }

    // AwaitMoveMessage
    //
    if (n.name () == "AwaitMoveMessage" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< AwaitMoveMessage_type > r (
        AwaitMoveMessage_traits::create (i, f, this));

      if (!this->AwaitMoveMessage_)
      {
        this->AwaitMoveMessage_.set (::std::move (r));
        continue;
      }
    }

    // MoveMessage
    //
    if (n.name () == "MoveMessage" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< MoveMessage_type > r (
        MoveMessage_traits::create (i, f, this));

      if (!this->MoveMessage_)
      {
        this->MoveMessage_.set (::std::move (r));
        continue;
      }
    }

    // AcceptMessage
    //
    if (n.name () == "AcceptMessage" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< AcceptMessage_type > r (
        AcceptMessage_traits::create (i, f, this));

      if (!this->AcceptMessage_)
      {
        this->AcceptMessage_.set (::std::move (r));
        continue;
      }
    }

    // WinMessage
    //
    if (n.name () == "WinMessage" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< WinMessage_type > r (
        WinMessage_traits::create (i, f, this));

      if (!this->WinMessage_)
      {
        this->WinMessage_.set (::std::move (r));
        continue;
      }
    }

    // DisconnectMessage
    //
    if (n.name () == "DisconnectMessage" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< DisconnectMessage_type > r (
        DisconnectMessage_traits::create (i, f, this));

      if (!this->DisconnectMessage_)
      {
        this->DisconnectMessage_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "mcType" && n.namespace_ ().empty ())
    {
      this->mcType_.set (mcType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!mcType_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "mcType",
      "");
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

MazeCom* MazeCom::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MazeCom (*this, f, c);
}

MazeCom& MazeCom::
operator= (const MazeCom& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->LoginMessage_ = x.LoginMessage_;
    this->LoginReplyMessage_ = x.LoginReplyMessage_;
    this->AwaitMoveMessage_ = x.AwaitMoveMessage_;
    this->MoveMessage_ = x.MoveMessage_;
    this->AcceptMessage_ = x.AcceptMessage_;
    this->WinMessage_ = x.WinMessage_;
    this->DisconnectMessage_ = x.DisconnectMessage_;
    this->mcType_ = x.mcType_;
    this->id_ = x.id_;
  }

  return *this;
}

MazeCom::
~MazeCom ()
{
}

// winner
//

winner::
winner (const id_type& id)
: ::xml_schema::string (),
  id_ (id, this)
{
}

winner::
winner (const char* _xsd_string_base,
        const id_type& id)
: ::xml_schema::string (_xsd_string_base),
  id_ (id, this)
{
}

winner::
winner (const ::std::string& _xsd_string_base,
        const id_type& id)
: ::xml_schema::string (_xsd_string_base),
  id_ (id, this)
{
}

winner::
winner (const ::xml_schema::string& _xsd_string_base,
        const id_type& id)
: ::xml_schema::string (_xsd_string_base),
  id_ (id, this)
{
}

winner::
winner (const winner& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  id_ (x.id_, f, this)
{
}

winner::
winner (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  id_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void winner::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "id" && n.namespace_ ().empty ())
    {
      this->id_.set (id_traits::create (i, f, this));
      continue;
    }
  }

  if (!id_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "id",
      "");
  }
}

winner* winner::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class winner (*this, f, c);
}

winner& winner::
operator= (const winner& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->id_ = x.id_;
  }

  return *this;
}

winner::
~winner ()
{
}

#include <ostream>

::std::ostream&
operator<< (::std::ostream& o, MazeComType::value i)
{
  return o << MazeComType::_xsd_MazeComType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const MazeComType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, treasureType::value i)
{
  return o << treasureType::_xsd_treasureType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const treasureType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, ErrorType::value i)
{
  return o << ErrorType::_xsd_ErrorType_literals_[i];
}

::std::ostream&
operator<< (::std::ostream& o, const ErrorType& i)
{
  return o << static_cast< const ::xml_schema::string& > (i);
}

::std::ostream&
operator<< (::std::ostream& o, const cardType& i)
{
  o << ::std::endl << "openings: " << i.openings ();
  o << ::std::endl << "pin: " << i.pin ();
  if (i.treasure ())
  {
    o << ::std::endl << "treasure: " << *i.treasure ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const boardType& i)
{
  for (boardType::row_const_iterator
       b (i.row ().begin ()), e (i.row ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "row: " << *b;
  }

  o << ::std::endl << "shiftCard: " << i.shiftCard ();
  if (i.forbidden ())
  {
    o << ::std::endl << "forbidden: " << *i.forbidden ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const positionType& i)
{
  o << ::std::endl << "row: " << i.row ();
  o << ::std::endl << "col: " << i.col ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const LoginMessageType& i)
{
  o << ::std::endl << "name: " << i.name ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const LoginReplyMessageType& i)
{
  o << ::std::endl << "newID: " << i.newID ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const AwaitMoveMessageType& i)
{
  o << ::std::endl << "board: " << i.board ();
  for (AwaitMoveMessageType::treasuresToGo_const_iterator
       b (i.treasuresToGo ().begin ()), e (i.treasuresToGo ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "treasuresToGo: " << *b;
  }

  for (AwaitMoveMessageType::foundTreasures_const_iterator
       b (i.foundTreasures ().begin ()), e (i.foundTreasures ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "foundTreasures: " << *b;
  }

  o << ::std::endl << "treasure: " << i.treasure ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const TreasuresToGoType& i)
{
  o << ::std::endl << "player: " << i.player ();
  o << ::std::endl << "treasures: " << i.treasures ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const MoveMessageType& i)
{
  o << ::std::endl << "shiftPosition: " << i.shiftPosition ();
  o << ::std::endl << "newPinPos: " << i.newPinPos ();
  o << ::std::endl << "shiftCard: " << i.shiftCard ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const AcceptMessageType& i)
{
  o << ::std::endl << "accept: " << i.accept ();
  o << ::std::endl << "errorCode: " << i.errorCode ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const WinMessageType& i)
{
  o << ::std::endl << "board: " << i.board ();
  o << ::std::endl << "winner: " << i.winner ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const DisconnectMessageType& i)
{
  o << ::std::endl << "name: " << i.name ();
  o << ::std::endl << "errorCode: " << i.errorCode ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const openings& i)
{
  o << ::std::endl << "top: " << i.top ();
  o << ::std::endl << "bottom: " << i.bottom ();
  o << ::std::endl << "left: " << i.left ();
  o << ::std::endl << "right: " << i.right ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const pin& i)
{
  for (pin::playerID_const_iterator
       b (i.playerID ().begin ()), e (i.playerID ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "playerID: " << *b;
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const row& i)
{
  for (row::col_const_iterator
       b (i.col ().begin ()), e (i.col ().end ());
       b != e; ++b)
  {
    o << ::std::endl << "col: " << *b;
  }

  if (i.OptionalAttirbute ())
  {
    o << ::std::endl << "OptionalAttirbute: " << *i.OptionalAttirbute ();
  }

  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const MazeCom& i)
{
  if (i.LoginMessage ())
  {
    o << ::std::endl << "LoginMessage: " << *i.LoginMessage ();
  }

  if (i.LoginReplyMessage ())
  {
    o << ::std::endl << "LoginReplyMessage: " << *i.LoginReplyMessage ();
  }

  if (i.AwaitMoveMessage ())
  {
    o << ::std::endl << "AwaitMoveMessage: " << *i.AwaitMoveMessage ();
  }

  if (i.MoveMessage ())
  {
    o << ::std::endl << "MoveMessage: " << *i.MoveMessage ();
  }

  if (i.AcceptMessage ())
  {
    o << ::std::endl << "AcceptMessage: " << *i.AcceptMessage ();
  }

  if (i.WinMessage ())
  {
    o << ::std::endl << "WinMessage: " << *i.WinMessage ();
  }

  if (i.DisconnectMessage ())
  {
    o << ::std::endl << "DisconnectMessage: " << *i.DisconnectMessage ();
  }

  o << ::std::endl << "mcType: " << i.mcType ();
  o << ::std::endl << "id: " << i.id ();
  return o;
}

::std::ostream&
operator<< (::std::ostream& o, const winner& i)
{
  o << static_cast< const ::xml_schema::string& > (i);

  o << ::std::endl << "id: " << i.id ();
  return o;
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::MazeCom >
MazeCom_ (const ::std::string& u,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::MazeCom > (
    ::MazeCom_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MazeCom >
MazeCom_ (const ::std::string& u,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::MazeCom > (
    ::MazeCom_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MazeCom >
MazeCom_ (const ::std::string& u,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::MazeCom > (
    ::MazeCom_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MazeCom >
MazeCom_ (::std::istream& is,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MazeCom_ (isrc, f, p);
}

::std::unique_ptr< ::MazeCom >
MazeCom_ (::std::istream& is,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MazeCom_ (isrc, h, f, p);
}

::std::unique_ptr< ::MazeCom >
MazeCom_ (::std::istream& is,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::MazeCom_ (isrc, h, f, p);
}

::std::unique_ptr< ::MazeCom >
MazeCom_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MazeCom_ (isrc, f, p);
}

::std::unique_ptr< ::MazeCom >
MazeCom_ (::std::istream& is,
          const ::std::string& sid,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MazeCom_ (isrc, h, f, p);
}

::std::unique_ptr< ::MazeCom >
MazeCom_ (::std::istream& is,
          const ::std::string& sid,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::MazeCom_ (isrc, h, f, p);
}

::std::unique_ptr< ::MazeCom >
MazeCom_ (::xercesc::InputSource& i,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::MazeCom > (
    ::MazeCom_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MazeCom >
MazeCom_ (::xercesc::InputSource& i,
          ::xml_schema::error_handler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::MazeCom > (
    ::MazeCom_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MazeCom >
MazeCom_ (::xercesc::InputSource& i,
          ::xercesc::DOMErrorHandler& h,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::MazeCom > (
    ::MazeCom_ (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::MazeCom >
MazeCom_ (const ::xercesc::DOMDocument& doc,
          ::xml_schema::flags f,
          const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::MazeCom > (
      ::MazeCom_ (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "MazeCom" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::MazeCom > r (
      ::xsd::cxx::tree::traits< ::MazeCom, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MazeCom",
    "");
}

::std::unique_ptr< ::MazeCom >
MazeCom_ (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
          ::xml_schema::flags f,
          const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "MazeCom" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::MazeCom > r (
      ::xsd::cxx::tree::traits< ::MazeCom, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "MazeCom",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const MazeComType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const MazeComType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const MazeComType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const treasureType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const treasureType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const treasureType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const ErrorType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ErrorType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ErrorType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const cardType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // openings
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "openings",
        e));

    s << i.openings ();
  }

  // pin
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "pin",
        e));

    s << i.pin ();
  }

  // treasure
  //
  if (i.treasure ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "treasure",
        e));

    s << *i.treasure ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const boardType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // row
  //
  for (boardType::row_const_iterator
       b (i.row ().begin ()), n (i.row ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "row",
        e));

    s << *b;
  }

  // shiftCard
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "shiftCard",
        e));

    s << i.shiftCard ();
  }

  // forbidden
  //
  if (i.forbidden ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "forbidden",
        e));

    s << *i.forbidden ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const positionType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // row
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "row",
        e));

    s << i.row ();
  }

  // col
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "col",
        e));

    s << i.col ();
  }
}

void
MazeCom_ (::std::ostream& o,
          const ::MazeCom& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::MazeCom_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
MazeCom_ (::std::ostream& o,
          const ::MazeCom& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::MazeCom_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
MazeCom_ (::std::ostream& o,
          const ::MazeCom& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::MazeCom_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
MazeCom_ (::xercesc::XMLFormatTarget& t,
          const ::MazeCom& s,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::MazeCom_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
MazeCom_ (::xercesc::XMLFormatTarget& t,
          const ::MazeCom& s,
          ::xml_schema::error_handler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::MazeCom_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
MazeCom_ (::xercesc::XMLFormatTarget& t,
          const ::MazeCom& s,
          ::xercesc::DOMErrorHandler& h,
          const ::xml_schema::namespace_infomap& m,
          const ::std::string& e,
          ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::MazeCom_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
MazeCom_ (::xercesc::DOMDocument& d,
          const ::MazeCom& s,
          ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "MazeCom" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "MazeCom",
      "");
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
MazeCom_ (const ::MazeCom& s,
          const ::xml_schema::namespace_infomap& m,
          ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "MazeCom",
      "",
      m, f));

  ::MazeCom_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const LoginMessageType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        e));

    s << i.name ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const LoginReplyMessageType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // newID
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "newID",
        e));

    s << i.newID ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const AwaitMoveMessageType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // board
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "board",
        e));

    s << i.board ();
  }

  // treasuresToGo
  //
  for (AwaitMoveMessageType::treasuresToGo_const_iterator
       b (i.treasuresToGo ().begin ()), n (i.treasuresToGo ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "treasuresToGo",
        e));

    s << *b;
  }

  // foundTreasures
  //
  for (AwaitMoveMessageType::foundTreasures_const_iterator
       b (i.foundTreasures ().begin ()), n (i.foundTreasures ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "foundTreasures",
        e));

    s << *b;
  }

  // treasure
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "treasure",
        e));

    s << i.treasure ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const TreasuresToGoType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // player
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "player",
        e));

    s << i.player ();
  }

  // treasures
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "treasures",
        e));

    s << i.treasures ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const MoveMessageType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // shiftPosition
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "shiftPosition",
        e));

    s << i.shiftPosition ();
  }

  // newPinPos
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "newPinPos",
        e));

    s << i.newPinPos ();
  }

  // shiftCard
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "shiftCard",
        e));

    s << i.shiftCard ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const AcceptMessageType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // accept
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "accept",
        e));

    s << i.accept ();
  }

  // errorCode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "errorCode",
        e));

    s << i.errorCode ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const WinMessageType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // board
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "board",
        e));

    s << i.board ();
  }

  // winner
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "winner",
        e));

    s << i.winner ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const DisconnectMessageType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // name
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "name",
        e));

    s << i.name ();
  }

  // errorCode
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "errorCode",
        e));

    s << i.errorCode ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const openings& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // top
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "top",
        e));

    s << i.top ();
  }

  // bottom
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "bottom",
        e));

    s << i.bottom ();
  }

  // left
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "left",
        e));

    s << i.left ();
  }

  // right
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "right",
        e));

    s << i.right ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const pin& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // playerID
  //
  for (pin::playerID_const_iterator
       b (i.playerID ().begin ()), n (i.playerID ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "playerID",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const row& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // col
  //
  for (row::col_const_iterator
       b (i.col ().begin ()), n (i.col ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "col",
        e));

    s << *b;
  }

  // OptionalAttirbute
  //
  if (i.OptionalAttirbute ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "OptionalAttirbute",
        e));

    a << *i.OptionalAttirbute ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const MazeCom& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // LoginMessage
  //
  if (i.LoginMessage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "LoginMessage",
        e));

    s << *i.LoginMessage ();
  }

  // LoginReplyMessage
  //
  if (i.LoginReplyMessage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "LoginReplyMessage",
        e));

    s << *i.LoginReplyMessage ();
  }

  // AwaitMoveMessage
  //
  if (i.AwaitMoveMessage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AwaitMoveMessage",
        e));

    s << *i.AwaitMoveMessage ();
  }

  // MoveMessage
  //
  if (i.MoveMessage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MoveMessage",
        e));

    s << *i.MoveMessage ();
  }

  // AcceptMessage
  //
  if (i.AcceptMessage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AcceptMessage",
        e));

    s << *i.AcceptMessage ();
  }

  // WinMessage
  //
  if (i.WinMessage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "WinMessage",
        e));

    s << *i.WinMessage ();
  }

  // DisconnectMessage
  //
  if (i.DisconnectMessage ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DisconnectMessage",
        e));

    s << *i.DisconnectMessage ();
  }

  // mcType
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "mcType",
        e));

    a << i.mcType ();
  }

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const winner& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // id
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "id",
        e));

    a << i.id ();
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

